use parser::peg::Pipeline;
use parser::pipelines;
use flow_control::Statement;
use flow_control::ElseIf;

#[pub]
parse_ -> Statement
      = if_
      / else_if_
      / else_
      / for_
      / while_
      / fn_
      / end_
      / pipelines

#[pub]
if_ -> Statement
    = whitespace* "if" whitespace? command:$(.*) {?
        let mut possible_error = None;
        let mut pipelines: Vec<Pipeline> = Vec::new();

        pipelines::collect(&mut pipelines, &mut possible_error, command);

        match possible_error {
            Some(error) => Err(error),
            None => match pipelines.drain(..).next() {
                Some(pipeline) => Ok(Statement::If {
                    expression: pipeline,
                    success: Vec::new(),
                    else_if: Vec::new(),
                    failure: Vec::new()
                }),
                None => unreachable!()
            }
        }
    }

#[pub]
else_if_ -> Statement
    = whitespace* "else" whitespace? "if" whitespace? command:$(.*) {?
        let mut possible_error = None;
        let mut pipelines: Vec<Pipeline> = Vec::new();

        pipelines::collect(&mut pipelines, &mut possible_error, command);

        match possible_error {
            Some(error) => Err(error),
            None => match pipelines.drain(..).next() {
                Some(pipeline) => Ok(Statement::ElseIf(ElseIf {
                    expression: pipeline,
                    success:    Vec::new(),
                })),
                None => unreachable!()
            }
        }
    }

#[pub]
else_ -> Statement
    = whitespace* "else" whitespace*  { Statement::Else}

#[pub]
end_ -> Statement
    = whitespace* "end" whitespace* { Statement ::End}

#[pub]
fn_ -> Statement
    = whitespace* "fn " n:_name whitespace* args:_args whitespace* {
        Statement::Function {
            name: n.to_string(),
            args: args,
            statements: Vec::new(),
        }
    }

_name -> String
      = n:$([A-z]+) { n.to_string() }

_args -> Vec<String>
      = _arg ** " "

_arg -> String
     = n:$([A-z0-9]+) { n.to_string() }

#[pub]
for_ -> Statement
    = whitespace* "for" whitespace? n:_name whitespace? "in" whitespace? expr:$(.*) {
        Statement::For {
            variable: n.to_string(),
            values: expr.to_string(),
            statements: Vec::new(),
        }
    }

#[pub]
while_ -> Statement
    = whitespace* "while" whitespace? command:$(.*) {?
        let mut possible_error = None;
        let mut pipelines: Vec<Pipeline> = Vec::new();

        pipelines::collect(&mut pipelines, &mut possible_error, command);

        match possible_error {
            Some(error) => Err(error),
            None => match pipelines.drain(..).next() {
                Some(pipeline) => Ok(Statement::While {
                    expression: pipeline,
                    statements: Vec::new()
                }),
                None => unreachable!()
            }
        }
    }

#[pub]
pipelines -> Statement
    = (unused* newline)* [#] .* { Statement::Pipelines(vec![]) }
    / [ \n\t\r]* _pipelines
    / (unused*) ** newline { Statement::Pipelines(vec![]) }


// Converts the pipeline string into a statement, handling redirection, piping, and backgrounds.
_pipelines -> Statement
    = command:$(.+) {?
    let mut possible_error = None;
    let mut pipelines: Vec<Pipeline> = Vec::new();

    pipelines::collect(&mut pipelines, &mut possible_error, command);

    match possible_error {
        Some(error) => Err(error),
        None        => Ok(Statement::Pipelines(pipelines))
    }
}

unused -> ()
    = whitespace comment? { () }
    / comment { () }

comment -> ()
    = [#] [^\r\n]*

whitespace -> ()
    = [ \t]+

job_ending -> ()
    = [;]
    / newline

newline -> ()
    = [\r\n]
