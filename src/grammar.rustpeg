use peg::Pipeline;
use peg::Job;
use peg::Redirection;
use peg::PipelineIterator;
use flow_control::Statement;
use flow_control::Comparitor;

#[pub]
parse_ -> Statement
      = if_
      / else_
      / for_
      / fn_
      / end_
      / pipelines

#[pub]
if_ -> Statement
    = whitespace* "if " l:_not_comparitor whitespace c:comparitor whitespace r:_not_comparitor whitespace* { Statement::If{ left: l, comparitor: c, right: r} }

#[pub]
else_ -> Statement
    = whitespace* "else" whitespace*  { Statement::Else}

#[pub]
end_ -> Statement
    = whitespace* "end" whitespace* { Statement ::End}

#[pub]
fn_ -> Statement
    = whitespace* "fn " n:_name whitespace* args:_args whitespace* { Statement::Function{name: n.to_string(), args: args} }

_name -> String
      = n:$([A-z]+) { n.to_string() }

_args -> Vec<String>
      = _arg ** " "

_arg -> String
     = n:$([A-z0-9]+) { n.to_string() }

#[pub]
for_ -> Statement
    = whitespace* "for " n:_name " in " args:_args whitespace* { Statement::For{variable: n.to_string(), values: args} }

comparitor -> Comparitor
    = "==" { Comparitor::Equal }
    / "!=" { Comparitor::NotEqual }
    / "<=" { Comparitor::LessThanOrEqual }
    / ">=" { Comparitor::GreaterThanOrEqual }
    / "<"  { Comparitor::LessThan }
    / ">"  { Comparitor::GreaterThan }

_not_comparitor -> String
    = !comparitor n:$([^ ]+) { n.to_string() }

#[pub]
pipelines -> Statement
    = (unused* newline)* [#] .* { Statement::Pipelines(vec![]) }
    / [ \n\t\r]* _pipelines
    / (unused*) ** newline { Statement::Pipelines(vec![]) }


// Converts the pipeline string into a statement, handling redirection, piping, and backgrounds.
_pipelines -> Statement
    = command:$(.+) {?
    let mut possible_error = None;
    let mut pipelines: Vec<Pipeline> = Vec::new();
    for args in PipelineIterator::new(command) {
        let mut args_iter = args.chars();
        let (mut index, mut comm_end, mut arg_start) = (0, 0, 0);

        while let Some(character) = args_iter.next() {
            if character == ' ' || character == '\t' {
                comm_end = index;
                break
            }
            index += 1;
        }

        if comm_end == 0 {
            let jobs = vec![Job::new(vec![args[0..].to_owned()], false)];
            pipelines.push(Pipeline::new(jobs, None, None));
        } else {
            while let Some(character) = args_iter.next() {
                index += 1;
                if character != ' ' && character != '\t' {
                    arg_start = index;
                    break
                }
            }

            if arg_start == 0 {
                let jobs = vec![Job::new(vec![args[0..comm_end].to_owned()], false)];
                pipelines.push(Pipeline::new(jobs, None, None));
            } else {
                let mut jobs: Vec<Job> = Vec::new();

                let (mut double_quote, mut single_quote, mut backslash) = (false, false, false);
                let mut process_match = 0;
                let mut arguments: Vec<String> = vec![args[0..comm_end].to_owned()];

                #[derive(PartialEq)]
                enum RedirMode { False, Stdin, Stdout, StdoutAppend }
                let (mut in_file, mut out_file) = (None, None);
                let mut mode = RedirMode::False;

                match args.chars().nth(index).unwrap() {
                    '\'' => single_quote = !single_quote,
                    '"'  => double_quote = !double_quote,
                    '$' if process_match == 0 => process_match = 1,
                    '\\' => backslash = !backslash,
                    '|'  => {
                        jobs.push(Job::new(arguments.clone(), false));
                        arguments.clear();
                        arg_start = index + 1;
                    },
                    '&' => {
                        jobs.push(Job::new(arguments.clone(), true));
                        arguments.clear();
                        arg_start = index + 1;
                    },
                    '>' => {
                        mode = RedirMode::Stdout;
                        arg_start = index + 1;
                    },
                    '<' => {
                        mode = RedirMode::Stdin;
                        arg_start = index + 1;
                    },
                    _    => ()
                }


                'outer: loop {
                    match mode {
                        RedirMode::False => {
                            while let Some(character) = args_iter.next() {
                                index += 1;
                                match character {
                                    _ if backslash => backslash = false,
                                    '\\' => backslash = true,
                                    '$'  if (process_match == 0) & !single_quote => process_match = 1,
                                    '('  if (process_match == 1) & !single_quote => process_match = 2,
                                    ')'  if (process_match == 2) & !single_quote => process_match = 0,
                                    '\'' => single_quote = !single_quote,
                                    '|'  if !double_quote & !single_quote & (process_match != 2) => {
                                        jobs.push(Job::new(arguments.clone(), false));
                                        arguments.clear();
                                        arg_start = index + 1;
                                    },
                                    '"'  => double_quote = !double_quote,
                                    ' ' | '\t' if !double_quote & !single_quote & (process_match != 2) => {
                                        if arg_start != index {
                                            arguments.push(args[arg_start..index].to_owned());
                                            arg_start = index + 1;
                                        } else {
                                            arg_start += 1;
                                        }
                                    },
                                    '&' if !double_quote & !single_quote & (process_match != 2) => {
                                        jobs.push(Job::new(arguments.clone(), true));
                                        arguments.clear();
                                        arg_start = index + 1;
                                    },
                                    '>' if !double_quote & !single_quote & (process_match != 2) => {
                                        mode = RedirMode::Stdout;
                                        arg_start = index + 1;
                                        continue 'outer
                                    },
                                    '<' if !double_quote & !single_quote & (process_match != 2) => {
                                        mode = RedirMode::Stdin;
                                        arg_start = index + 1;
                                        continue 'outer
                                    },
                                    _ if process_match != 2 => process_match = 0,
                                    _ => (),
                                }
                            }
                            break 'outer
                        },
                        RedirMode::Stdout | RedirMode::StdoutAppend => {
                            match args_iter.next() {
                                Some(character) => match character {
                                    '>' => mode = RedirMode::StdoutAppend,
                                    _   => (),
                                },
                                None => {
                                    possible_error = Some("missing standard output file argument after '>'");
                                    break 'outer
                                }
                            }

                            let mut stdout_file = String::new();
                            let mut found_file = false;
                            while let Some(character) = args_iter.next() {
                                if found_file {
                                    if character == '<' {
                                        if in_file.is_some() {
                                            break 'outer
                                        } else {
                                            mode = RedirMode::Stdin;
                                            continue 'outer
                                        }
                                    }
                                } else {
                                    match character {
                                        _ if backslash => {
                                            stdout_file.push(character);
                                            backslash = false;
                                        }
                                        '\\' => backslash = false,
                                        ' ' | '\t' | '|' if stdout_file.is_empty() => (),
                                        ' ' | '\t' | '|' => {
                                            found_file = true;
                                            out_file = Some(Redirection {
                                                file: stdout_file.clone(),
                                                append: mode == RedirMode::StdoutAppend
                                            });
                                        },
                                        '<' if stdout_file.is_empty() => {
                                            possible_error = Some("missing standard output file argument after '>'");
                                            break 'outer
                                        }
                                        '<' => {
                                            out_file = Some(Redirection {
                                                file: stdout_file.clone(),
                                                append: mode == RedirMode::StdoutAppend
                                            });

                                            if in_file.is_some() {
                                                break 'outer
                                            } else {
                                                mode = RedirMode::Stdin;
                                                continue 'outer
                                            }
                                        },
                                        _ => stdout_file.push(character),
                                    }
                                }
                            }

                            if out_file.is_none() {
                                if stdout_file.is_empty() {
                                    possible_error = Some("missing standard output file argument after '>'");
                                } else {
                                    out_file = Some(Redirection {
                                        file: stdout_file,
                                        append: mode == RedirMode::StdoutAppend
                                    });
                                }
                            }

                            break 'outer
                        },
                        RedirMode::Stdin => {
                            let mut stdin_file = String::new();
                            let mut found_file = false;
                            while let Some(character) = args_iter.next() {
                                if found_file {
                                    if character == '>' {
                                        if out_file.is_some() {
                                            break 'outer
                                        } else {
                                            mode = RedirMode::Stdout;
                                            continue 'outer
                                        }
                                    }
                                } else {
                                    match character {
                                        _ if backslash => {
                                            stdin_file.push(character);
                                            backslash = false;
                                        }
                                        '\\' => backslash = false,
                                        ' ' | '\t' | '|' if stdin_file.is_empty() => (),
                                        ' ' | '\t' | '|' => {
                                            found_file = true;
                                            in_file = Some(Redirection { file: stdin_file.clone(), append: false });
                                        },
                                        '>' if stdin_file.is_empty() => {
                                            possible_error = Some("missing standard input file argument after '<'");
                                            break 'outer
                                        }
                                        '>' => {
                                            in_file = Some(Redirection { file: stdin_file.clone(), append: false });

                                            if out_file.is_some() {
                                                break 'outer
                                            } else {
                                                mode = RedirMode::Stdin;
                                                continue 'outer
                                            }
                                        },
                                        _ => stdin_file.push(character),
                                    }
                                }
                            }

                            if in_file.is_none() {
                                if stdin_file.is_empty() {
                                    possible_error = Some("missing standard input file argument after '<'");
                                } else {
                                    in_file = Some(Redirection { file: stdin_file, append: false });
                                }
                            }

                            break 'outer
                        }
                    }
                }

                if arg_start < index+1 {
                    arguments.push(args[arg_start..index+1].to_owned());
                }

                if !arguments.is_empty() {
                    jobs.push(Job::new(arguments, false));
                }

                pipelines.push(Pipeline::new(jobs, in_file, out_file));
            }
        }
    }

    if possible_error.is_none() {
        Ok(Statement::Pipelines(pipelines))
    } else {
        Err(possible_error.unwrap())
    }
}

unused -> ()
    = whitespace comment? { () }
    / comment { () }

comment -> ()
    = [#] [^\r\n]*

whitespace -> ()
    = [ \t]+

job_ending -> ()
    = [;]
    / newline

newline -> ()
    = [\r\n]
